diff --git a/lib/filters/defaults/noise/noise.frag.mjs b/lib/filters/defaults/noise/noise.frag.mjs
index 7f222ad15833229a6557fcef26629cf8428fbab7..dce9e5a511c12d77251f0064b18e5a56151914ab 100644
--- a/lib/filters/defaults/noise/noise.frag.mjs
+++ b/lib/filters/defaults/noise/noise.frag.mjs
@@ -1,4 +1,5 @@
-var fragment = "\nin vec2 vTextureCoord;\nin vec4 vColor;\n\nout vec4 finalColor;\n\nuniform float uNoise;\nuniform float uSeed;\nuniform sampler2D uTexture;\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main()\n{\n    vec4 color = texture(uTexture, vTextureCoord);\n    float randomValue = rand(gl_FragCoord.xy * 0.2);\n    float diff = (randomValue - 0.5) *  0.5;\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (color.a > 0.0) {\n        color.rgb /= color.a;\n    }\n\n    color.r += diff;\n    color.g += diff;\n    color.b += diff;\n\n    // Premultiply alpha again.\n    color.rgb *= color.a;\n\n    finalColor = color;\n}\n";
+var fragment =
+  "\nin vec2 vTextureCoord;\nin vec4 vColor;\n\nout vec4 finalColor;\n\nuniform float uNoise;\nuniform float uSeed;\nuniform sampler2D uTexture;\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main()\n{\n    vec4 color = texture(uTexture, vTextureCoord);\n    float randomValue = rand(gl_FragCoord.xy * uSeed);\n    float diff = (randomValue - 0.5) *  uNoise;\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (color.a > 0.0) {\n        color.rgb /= color.a;\n    }\n\n    color.r += diff;\n    color.g += diff;\n    color.b += diff;\n\n    // Premultiply alpha again.\n    color.rgb *= color.a;\n\n    finalColor = color;\n}\n";
 
 export { fragment as default };
 //# sourceMappingURL=noise.frag.mjs.map
diff --git a/lib/scene/mesh/shared/MeshPipe.js b/lib/scene/mesh/shared/MeshPipe.js
index 1f36825234e90f7a778ed08c9128806e59450194..3d9de4d520b48f4411e3ac8dd4257feab7bd01ee 100644
--- a/lib/scene/mesh/shared/MeshPipe.js
+++ b/lib/scene/mesh/shared/MeshPipe.js
@@ -1,23 +1,23 @@
-'use strict';
+"use strict";
 
-var Extensions = require('../../../extensions/Extensions.js');
-var Matrix = require('../../../maths/matrix/Matrix.js');
-var BindGroup = require('../../../rendering/renderers/gpu/shader/BindGroup.js');
-var UniformGroup = require('../../../rendering/renderers/shared/shader/UniformGroup.js');
-var PoolGroup = require('../../../utils/pool/PoolGroup.js');
-var colorToUniform = require('../../graphics/gpu/colorToUniform.js');
-var BatchableMesh = require('./BatchableMesh.js');
+var Extensions = require("../../../extensions/Extensions.js");
+var Matrix = require("../../../maths/matrix/Matrix.js");
+var BindGroup = require("../../../rendering/renderers/gpu/shader/BindGroup.js");
+var UniformGroup = require("../../../rendering/renderers/shared/shader/UniformGroup.js");
+var PoolGroup = require("../../../utils/pool/PoolGroup.js");
+var colorToUniform = require("../../graphics/gpu/colorToUniform.js");
+var BatchableMesh = require("./BatchableMesh.js");
 
-"use strict";
+("use strict");
 class MeshPipe {
   constructor(renderer, adaptor) {
     this.localUniforms = new UniformGroup.UniformGroup({
       uTransformMatrix: { value: new Matrix.Matrix(), type: "mat3x3<f32>" },
       uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
-      uRound: { value: 0, type: "f32" }
+      uRound: { value: 0, type: "f32" },
     });
     this.localUniformsBindGroup = new BindGroup.BindGroup({
-      0: this.localUniforms
+      0: this.localUniforms,
     });
     this._meshDataHash = /* @__PURE__ */ Object.create(null);
     this._gpuBatchableMeshHash = /* @__PURE__ */ Object.create(null);
@@ -34,7 +34,10 @@ class MeshPipe {
       return true;
     } else if (isBatched) {
       const geometry = mesh._geometry;
-      if (geometry.indices.length !== meshData.indexSize || geometry.positions.length !== meshData.vertexSize) {
+      if (
+        geometry.indices.length !== meshData.indexSize ||
+        geometry.positions.length !== meshData.vertexSize
+      ) {
         meshData.indexSize = geometry.indices.length;
         meshData.vertexSize = geometry.positions.length;
         return true;
@@ -43,7 +46,10 @@ class MeshPipe {
       const texture = mesh.texture;
       if (batchableMesh.texture._source !== texture._source) {
         if (batchableMesh.texture._source !== texture._source) {
-          return !batchableMesh.batcher.checkAndUpdateTexture(batchableMesh, texture);
+          return !batchableMesh.batcher.checkAndUpdateTexture(
+            batchableMesh,
+            texture
+          );
         }
       }
     }
@@ -61,7 +67,7 @@ class MeshPipe {
       batcher.break(instructionSet);
       instructionSet.add({
         renderPipeId: "mesh",
-        mesh
+        mesh,
       });
     }
   }
@@ -76,16 +82,16 @@ class MeshPipe {
   destroyRenderable(mesh) {
     this._meshDataHash[mesh.uid] = null;
     const gpuMesh = this._gpuBatchableMeshHash[mesh.uid];
-    PoolGroup.BigPool.return(gpuMesh);
+    gpuMesh && PoolGroup.BigPool.return(gpuMesh);
     this._gpuBatchableMeshHash[mesh.uid] = null;
   }
   execute({ mesh }) {
-    if (!mesh.isRenderable)
-      return;
+    if (!mesh.isRenderable) return;
     mesh.state.blendMode = mesh.groupBlendMode;
     const localUniforms = this.localUniforms;
     localUniforms.uniforms.uTransformMatrix = mesh.groupTransform;
-    localUniforms.uniforms.uRound = this.renderer._roundPixels | mesh._roundPixels;
+    localUniforms.uniforms.uRound =
+      this.renderer._roundPixels | mesh._roundPixels;
     localUniforms.update();
     colorToUniform.color32BitToUniform(
       mesh.groupColorAlpha,
@@ -101,7 +107,7 @@ class MeshPipe {
     this._meshDataHash[mesh.uid] = {
       batched: mesh.batched,
       indexSize: mesh._geometry.indices?.length,
-      vertexSize: mesh._geometry.positions?.length
+      vertexSize: mesh._geometry.positions?.length,
     };
     mesh.on("destroyed", () => {
       this.destroyRenderable(mesh);
@@ -109,7 +115,9 @@ class MeshPipe {
     return this._meshDataHash[mesh.uid];
   }
   _getBatchableMesh(mesh) {
-    return this._gpuBatchableMeshHash[mesh.uid] || this._initBatchableMesh(mesh);
+    return (
+      this._gpuBatchableMeshHash[mesh.uid] || this._initBatchableMesh(mesh)
+    );
   }
   _initBatchableMesh(mesh) {
     const gpuMesh = PoolGroup.BigPool.get(BatchableMesh.BatchableMesh);
@@ -140,9 +148,9 @@ MeshPipe.extension = {
   type: [
     Extensions.ExtensionType.WebGLPipes,
     Extensions.ExtensionType.WebGPUPipes,
-    Extensions.ExtensionType.CanvasPipes
+    Extensions.ExtensionType.CanvasPipes,
   ],
-  name: "mesh"
+  name: "mesh",
 };
 
 exports.MeshPipe = MeshPipe;
diff --git a/lib/scene/mesh/shared/MeshPipe.mjs b/lib/scene/mesh/shared/MeshPipe.mjs
index 187f6079d8cc14c5717aa44534d22b7aab106a4d..f9f9c5253001d0f4942957f3bd9b9b1e6848df63 100644
--- a/lib/scene/mesh/shared/MeshPipe.mjs
+++ b/lib/scene/mesh/shared/MeshPipe.mjs
@@ -1,21 +1,21 @@
-import { ExtensionType } from '../../../extensions/Extensions.mjs';
-import { Matrix } from '../../../maths/matrix/Matrix.mjs';
-import { BindGroup } from '../../../rendering/renderers/gpu/shader/BindGroup.mjs';
-import { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup.mjs';
-import { BigPool } from '../../../utils/pool/PoolGroup.mjs';
-import { color32BitToUniform } from '../../graphics/gpu/colorToUniform.mjs';
-import { BatchableMesh } from './BatchableMesh.mjs';
+import { ExtensionType } from "../../../extensions/Extensions.mjs";
+import { Matrix } from "../../../maths/matrix/Matrix.mjs";
+import { BindGroup } from "../../../rendering/renderers/gpu/shader/BindGroup.mjs";
+import { UniformGroup } from "../../../rendering/renderers/shared/shader/UniformGroup.mjs";
+import { BigPool } from "../../../utils/pool/PoolGroup.mjs";
+import { color32BitToUniform } from "../../graphics/gpu/colorToUniform.mjs";
+import { BatchableMesh } from "./BatchableMesh.mjs";
 
-"use strict";
+("use strict");
 class MeshPipe {
   constructor(renderer, adaptor) {
     this.localUniforms = new UniformGroup({
       uTransformMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
       uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
-      uRound: { value: 0, type: "f32" }
+      uRound: { value: 0, type: "f32" },
     });
     this.localUniformsBindGroup = new BindGroup({
-      0: this.localUniforms
+      0: this.localUniforms,
     });
     this._meshDataHash = /* @__PURE__ */ Object.create(null);
     this._gpuBatchableMeshHash = /* @__PURE__ */ Object.create(null);
@@ -32,7 +32,10 @@ class MeshPipe {
       return true;
     } else if (isBatched) {
       const geometry = mesh._geometry;
-      if (geometry.indices.length !== meshData.indexSize || geometry.positions.length !== meshData.vertexSize) {
+      if (
+        geometry.indices.length !== meshData.indexSize ||
+        geometry.positions.length !== meshData.vertexSize
+      ) {
         meshData.indexSize = geometry.indices.length;
         meshData.vertexSize = geometry.positions.length;
         return true;
@@ -41,7 +44,10 @@ class MeshPipe {
       const texture = mesh.texture;
       if (batchableMesh.texture._source !== texture._source) {
         if (batchableMesh.texture._source !== texture._source) {
-          return !batchableMesh.batcher.checkAndUpdateTexture(batchableMesh, texture);
+          return !batchableMesh.batcher.checkAndUpdateTexture(
+            batchableMesh,
+            texture
+          );
         }
       }
     }
@@ -59,7 +65,7 @@ class MeshPipe {
       batcher.break(instructionSet);
       instructionSet.add({
         renderPipeId: "mesh",
-        mesh
+        mesh,
       });
     }
   }
@@ -74,22 +80,18 @@ class MeshPipe {
   destroyRenderable(mesh) {
     this._meshDataHash[mesh.uid] = null;
     const gpuMesh = this._gpuBatchableMeshHash[mesh.uid];
-    BigPool.return(gpuMesh);
+    gpuMesh && BigPool.return(gpuMesh);
     this._gpuBatchableMeshHash[mesh.uid] = null;
   }
   execute({ mesh }) {
-    if (!mesh.isRenderable)
-      return;
+    if (!mesh.isRenderable) return;
     mesh.state.blendMode = mesh.groupBlendMode;
     const localUniforms = this.localUniforms;
     localUniforms.uniforms.uTransformMatrix = mesh.groupTransform;
-    localUniforms.uniforms.uRound = this.renderer._roundPixels | mesh._roundPixels;
+    localUniforms.uniforms.uRound =
+      this.renderer._roundPixels | mesh._roundPixels;
     localUniforms.update();
-    color32BitToUniform(
-      mesh.groupColorAlpha,
-      localUniforms.uniforms.uColor,
-      0
-    );
+    color32BitToUniform(mesh.groupColorAlpha, localUniforms.uniforms.uColor, 0);
     this._adaptor.execute(this, mesh);
   }
   _getMeshData(mesh) {
@@ -99,7 +101,7 @@ class MeshPipe {
     this._meshDataHash[mesh.uid] = {
       batched: mesh.batched,
       indexSize: mesh._geometry.indices?.length,
-      vertexSize: mesh._geometry.positions?.length
+      vertexSize: mesh._geometry.positions?.length,
     };
     mesh.on("destroyed", () => {
       this.destroyRenderable(mesh);
@@ -107,7 +109,9 @@ class MeshPipe {
     return this._meshDataHash[mesh.uid];
   }
   _getBatchableMesh(mesh) {
-    return this._gpuBatchableMeshHash[mesh.uid] || this._initBatchableMesh(mesh);
+    return (
+      this._gpuBatchableMeshHash[mesh.uid] || this._initBatchableMesh(mesh)
+    );
   }
   _initBatchableMesh(mesh) {
     const gpuMesh = BigPool.get(BatchableMesh);
@@ -138,9 +142,9 @@ MeshPipe.extension = {
   type: [
     ExtensionType.WebGLPipes,
     ExtensionType.WebGPUPipes,
-    ExtensionType.CanvasPipes
+    ExtensionType.CanvasPipes,
   ],
-  name: "mesh"
+  name: "mesh",
 };
 
 export { MeshPipe };
