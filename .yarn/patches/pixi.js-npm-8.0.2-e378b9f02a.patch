diff --git a/lib/rendering/renderers/gl/geometry/GlGeometrySystem.js b/lib/rendering/renderers/gl/geometry/GlGeometrySystem.js
index e6746ad967937d9d40ac38df9102f5686ebe56c2..c45b5321a799bd106715d9cddf8959d4e3b409f4 100644
--- a/lib/rendering/renderers/gl/geometry/GlGeometrySystem.js
+++ b/lib/rendering/renderers/gl/geometry/GlGeometrySystem.js
@@ -1,17 +1,17 @@
-'use strict';
+"use strict";
 
-var Extensions = require('../../../../extensions/Extensions.js');
-var getAttributeInfoFromFormat = require('../../shared/geometry/utils/getAttributeInfoFromFormat.js');
-var ensureAttributes = require('../shader/program/ensureAttributes.js');
-var getGlTypeFromFormat = require('./utils/getGlTypeFromFormat.js');
+var Extensions = require("../../../../extensions/Extensions.js");
+var getAttributeInfoFromFormat = require("../../shared/geometry/utils/getAttributeInfoFromFormat.js");
+var ensureAttributes = require("../shader/program/ensureAttributes.js");
+var getGlTypeFromFormat = require("./utils/getGlTypeFromFormat.js");
 
-"use strict";
+("use strict");
 const topologyToGlMap = {
   "point-list": 0,
   "line-list": 1,
   "line-strip": 3,
   "triangle-list": 4,
-  "triangle-strip": 5
+  "triangle-strip": 5,
 };
 class GlGeometrySystem {
   /** @param renderer - The renderer this System works for. */
@@ -25,17 +25,22 @@ class GlGeometrySystem {
   }
   /** Sets up the renderer context and necessary buffers. */
   contextChange() {
-    const gl = this.gl = this._renderer.gl;
+    const gl = (this.gl = this._renderer.gl);
     if (!this._renderer.context.supports.vertexArrayObject) {
-      throw new Error("[PixiJS] Vertex Array Objects are not supported on this device");
+      throw new Error(
+        "[PixiJS] Vertex Array Objects are not supported on this device"
+      );
     }
-    const nativeVaoExtension = this._renderer.context.extensions.vertexArrayObject;
+    const nativeVaoExtension =
+      this._renderer.context.extensions.vertexArrayObject;
     if (nativeVaoExtension) {
       gl.createVertexArray = () => nativeVaoExtension.createVertexArrayOES();
       gl.bindVertexArray = (vao) => nativeVaoExtension.bindVertexArrayOES(vao);
-      gl.deleteVertexArray = (vao) => nativeVaoExtension.deleteVertexArrayOES(vao);
+      gl.deleteVertexArray = (vao) =>
+        nativeVaoExtension.deleteVertexArrayOES(vao);
     }
-    const nativeInstancedExtension = this._renderer.context.extensions.vertexAttribDivisorANGLE;
+    const nativeInstancedExtension =
+      this._renderer.context.extensions.vertexAttribDivisorANGLE;
     if (nativeInstancedExtension) {
       gl.drawArraysInstanced = (a, b, c, d) => {
         nativeInstancedExtension.drawArraysInstancedANGLE(a, b, c, d);
@@ -43,7 +48,8 @@ class GlGeometrySystem {
       gl.drawElementsInstanced = (a, b, c, d, e) => {
         nativeInstancedExtension.drawElementsInstancedANGLE(a, b, c, d, e);
       };
-      gl.vertexAttribDivisor = (a, b) => nativeInstancedExtension.vertexAttribDivisorANGLE(a, b);
+      gl.vertexAttribDivisor = (a, b) =>
+        nativeInstancedExtension.vertexAttribDivisorANGLE(a, b);
     }
     this._activeGeometry = null;
     this._activeVao = null;
@@ -87,7 +93,9 @@ class GlGeometrySystem {
     const shaderAttributes = program._attributeData;
     for (const j in shaderAttributes) {
       if (!geometryAttributes[j]) {
-        throw new Error(`shader and geometry incompatible, geometry missing the "${j}" attribute`);
+        throw new Error(
+          `shader and geometry incompatible, geometry missing the "${j}" attribute`
+        );
       }
     }
   }
@@ -109,7 +117,10 @@ class GlGeometrySystem {
     return strings.join("-");
   }
   getVao(geometry, program) {
-    return this._geometryVaoHash[geometry.uid]?.[program._key] || this.initGeometryVao(geometry, program);
+    return (
+      this._geometryVaoHash[geometry.uid]?.[program._key] ||
+      this.initGeometryVao(geometry, program)
+    );
   }
   /**
    * Creates or gets Vao with the same structure as the geometry and stores it on the geometry.
@@ -212,7 +223,10 @@ class GlGeometrySystem {
         }
         const location = attribute.location;
         gl.enableVertexAttribArray(location);
-        const attributeInfo = getAttributeInfoFromFormat.getAttributeInfoFromFormat(attribute.format);
+        const attributeInfo =
+          getAttributeInfoFromFormat.getAttributeInfoFromFormat(
+            attribute.format
+          );
         gl.vertexAttribPointer(
           location,
           attributeInfo.size,
@@ -223,9 +237,14 @@ class GlGeometrySystem {
         );
         if (attribute.instance) {
           if (this.hasInstance) {
-            gl.vertexAttribDivisor(location, 1);
+            const divisor = Object.hasOwn(attribute, "divisor")
+              ? attribute.divisor
+              : 1;
+            gl.vertexAttribDivisor(location, divisor);
           } else {
-            throw new Error("geometry error, GPU Instancing is not supported on this device");
+            throw new Error(
+              "geometry error, GPU Instancing is not supported on this device"
+            );
           }
         }
       }
@@ -250,12 +269,28 @@ class GlGeometrySystem {
       const byteSize = geometry.indexBuffer.data.BYTES_PER_ELEMENT;
       const glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;
       if (instanceCount > 1) {
-        gl.drawElementsInstanced(glTopology, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize, instanceCount);
+        gl.drawElementsInstanced(
+          glTopology,
+          size || geometry.indexBuffer.data.length,
+          glType,
+          (start || 0) * byteSize,
+          instanceCount
+        );
       } else {
-        gl.drawElements(glTopology, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize);
+        gl.drawElements(
+          glTopology,
+          size || geometry.indexBuffer.data.length,
+          glType,
+          (start || 0) * byteSize
+        );
       }
     } else if (instanceCount > 1) {
-      gl.drawArraysInstanced(glTopology, start || 0, size || geometry.getSize(), instanceCount);
+      gl.drawArraysInstanced(
+        glTopology,
+        start || 0,
+        size || geometry.getSize(),
+        instanceCount
+      );
     } else {
       gl.drawArrays(glTopology, start || 0, size || geometry.getSize());
     }
@@ -276,10 +311,8 @@ class GlGeometrySystem {
 }
 /** @ignore */
 GlGeometrySystem.extension = {
-  type: [
-    Extensions.ExtensionType.WebGLSystem
-  ],
-  name: "geometry"
+  type: [Extensions.ExtensionType.WebGLSystem],
+  name: "geometry",
 };
 
 exports.GlGeometrySystem = GlGeometrySystem;
diff --git a/lib/rendering/renderers/gl/geometry/GlGeometrySystem.mjs b/lib/rendering/renderers/gl/geometry/GlGeometrySystem.mjs
index 6a2e467605d3eb2daf975f540983905e29787838..e8296e74895f40be9a42983443b6a52b2db35362 100644
--- a/lib/rendering/renderers/gl/geometry/GlGeometrySystem.mjs
+++ b/lib/rendering/renderers/gl/geometry/GlGeometrySystem.mjs
@@ -1,15 +1,15 @@
-import { ExtensionType } from '../../../../extensions/Extensions.mjs';
-import { getAttributeInfoFromFormat } from '../../shared/geometry/utils/getAttributeInfoFromFormat.mjs';
-import { ensureAttributes } from '../shader/program/ensureAttributes.mjs';
-import { getGlTypeFromFormat } from './utils/getGlTypeFromFormat.mjs';
+import { ExtensionType } from "../../../../extensions/Extensions.mjs";
+import { getAttributeInfoFromFormat } from "../../shared/geometry/utils/getAttributeInfoFromFormat.mjs";
+import { ensureAttributes } from "../shader/program/ensureAttributes.mjs";
+import { getGlTypeFromFormat } from "./utils/getGlTypeFromFormat.mjs";
 
-"use strict";
+("use strict");
 const topologyToGlMap = {
   "point-list": 0,
   "line-list": 1,
   "line-strip": 3,
   "triangle-list": 4,
-  "triangle-strip": 5
+  "triangle-strip": 5,
 };
 class GlGeometrySystem {
   /** @param renderer - The renderer this System works for. */
@@ -23,17 +23,22 @@ class GlGeometrySystem {
   }
   /** Sets up the renderer context and necessary buffers. */
   contextChange() {
-    const gl = this.gl = this._renderer.gl;
+    const gl = (this.gl = this._renderer.gl);
     if (!this._renderer.context.supports.vertexArrayObject) {
-      throw new Error("[PixiJS] Vertex Array Objects are not supported on this device");
+      throw new Error(
+        "[PixiJS] Vertex Array Objects are not supported on this device"
+      );
     }
-    const nativeVaoExtension = this._renderer.context.extensions.vertexArrayObject;
+    const nativeVaoExtension =
+      this._renderer.context.extensions.vertexArrayObject;
     if (nativeVaoExtension) {
       gl.createVertexArray = () => nativeVaoExtension.createVertexArrayOES();
       gl.bindVertexArray = (vao) => nativeVaoExtension.bindVertexArrayOES(vao);
-      gl.deleteVertexArray = (vao) => nativeVaoExtension.deleteVertexArrayOES(vao);
+      gl.deleteVertexArray = (vao) =>
+        nativeVaoExtension.deleteVertexArrayOES(vao);
     }
-    const nativeInstancedExtension = this._renderer.context.extensions.vertexAttribDivisorANGLE;
+    const nativeInstancedExtension =
+      this._renderer.context.extensions.vertexAttribDivisorANGLE;
     if (nativeInstancedExtension) {
       gl.drawArraysInstanced = (a, b, c, d) => {
         nativeInstancedExtension.drawArraysInstancedANGLE(a, b, c, d);
@@ -41,7 +46,8 @@ class GlGeometrySystem {
       gl.drawElementsInstanced = (a, b, c, d, e) => {
         nativeInstancedExtension.drawElementsInstancedANGLE(a, b, c, d, e);
       };
-      gl.vertexAttribDivisor = (a, b) => nativeInstancedExtension.vertexAttribDivisorANGLE(a, b);
+      gl.vertexAttribDivisor = (a, b) =>
+        nativeInstancedExtension.vertexAttribDivisorANGLE(a, b);
     }
     this._activeGeometry = null;
     this._activeVao = null;
@@ -85,7 +91,9 @@ class GlGeometrySystem {
     const shaderAttributes = program._attributeData;
     for (const j in shaderAttributes) {
       if (!geometryAttributes[j]) {
-        throw new Error(`shader and geometry incompatible, geometry missing the "${j}" attribute`);
+        throw new Error(
+          `shader and geometry incompatible, geometry missing the "${j}" attribute`
+        );
       }
     }
   }
@@ -107,7 +115,10 @@ class GlGeometrySystem {
     return strings.join("-");
   }
   getVao(geometry, program) {
-    return this._geometryVaoHash[geometry.uid]?.[program._key] || this.initGeometryVao(geometry, program);
+    return (
+      this._geometryVaoHash[geometry.uid]?.[program._key] ||
+      this.initGeometryVao(geometry, program)
+    );
   }
   /**
    * Creates or gets Vao with the same structure as the geometry and stores it on the geometry.
@@ -221,9 +232,14 @@ class GlGeometrySystem {
         );
         if (attribute.instance) {
           if (this.hasInstance) {
-            gl.vertexAttribDivisor(location, 1);
+            const divisor = Object.hasOwn(attribute, "divisor")
+              ? attribute.divisor
+              : 1;
+            gl.vertexAttribDivisor(location, divisor);
           } else {
-            throw new Error("geometry error, GPU Instancing is not supported on this device");
+            throw new Error(
+              "geometry error, GPU Instancing is not supported on this device"
+            );
           }
         }
       }
@@ -248,12 +264,28 @@ class GlGeometrySystem {
       const byteSize = geometry.indexBuffer.data.BYTES_PER_ELEMENT;
       const glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;
       if (instanceCount > 1) {
-        gl.drawElementsInstanced(glTopology, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize, instanceCount);
+        gl.drawElementsInstanced(
+          glTopology,
+          size || geometry.indexBuffer.data.length,
+          glType,
+          (start || 0) * byteSize,
+          instanceCount
+        );
       } else {
-        gl.drawElements(glTopology, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize);
+        gl.drawElements(
+          glTopology,
+          size || geometry.indexBuffer.data.length,
+          glType,
+          (start || 0) * byteSize
+        );
       }
     } else if (instanceCount > 1) {
-      gl.drawArraysInstanced(glTopology, start || 0, size || geometry.getSize(), instanceCount);
+      gl.drawArraysInstanced(
+        glTopology,
+        start || 0,
+        size || geometry.getSize(),
+        instanceCount
+      );
     } else {
       gl.drawArrays(glTopology, start || 0, size || geometry.getSize());
     }
@@ -274,10 +306,8 @@ class GlGeometrySystem {
 }
 /** @ignore */
 GlGeometrySystem.extension = {
-  type: [
-    ExtensionType.WebGLSystem
-  ],
-  name: "geometry"
+  type: [ExtensionType.WebGLSystem],
+  name: "geometry",
 };
 
 export { GlGeometrySystem };
diff --git a/lib/rendering/renderers/shared/geometry/Geometry.d.ts b/lib/rendering/renderers/shared/geometry/Geometry.d.ts
index 5adb8711c10eb98e2e1c971ceedc526433d077cd..668dc5d3af5f9cc6721638bdb264dae10702ae82 100644
--- a/lib/rendering/renderers/shared/geometry/Geometry.d.ts
+++ b/lib/rendering/renderers/shared/geometry/Geometry.d.ts
@@ -1,58 +1,63 @@
-import EventEmitter from 'eventemitter3';
-import { Bounds } from '../../../../scene/container/bounds/Bounds';
-import { Buffer } from '../buffer/Buffer';
-import type { TypedArray } from '../buffer/Buffer';
-import type { Topology, VertexFormat } from './const';
+import EventEmitter from "eventemitter3";
+import { Bounds } from "../../../../scene/container/bounds/Bounds";
+import { Buffer } from "../buffer/Buffer";
+import type { TypedArray } from "../buffer/Buffer";
+import type { Topology, VertexFormat } from "./const";
 export type IndexBufferArray = Uint16Array | Uint32Array;
 /**
  * The attribute data for a geometries attributes
  * @memberof rendering
  */
 export interface Attribute {
-    /** the buffer that this attributes data belongs to */
-    buffer: Buffer;
-    /** the format of the attribute */
-    format?: VertexFormat;
-    /** set where the shader location is for this attribute */
-    location?: number;
-    /** the stride of the data in the buffer*/
-    stride?: number;
-    /** the offset of the attribute from the buffer, defaults to 0 */
-    offset?: number;
-    /** is this an instanced buffer? (defaults to false) */
-    instance?: boolean;
-    /**  The number of elements to be rendered. If not specified, all vertices after the starting vertex will be drawn. */
-    size?: number;
-    /** the type of attribute  */
-    type?: number;
-    /**
-     * The starting vertex in the geometry to start drawing from. If not specified,
-     *  drawing will start from the first vertex.
-     */
-    start?: number;
+  /** the buffer that this attributes data belongs to */
+  buffer: Buffer;
+  /** the format of the attribute */
+  format?: VertexFormat;
+  /** set where the shader location is for this attribute */
+  location?: number;
+  /** the stride of the data in the buffer*/
+  stride?: number;
+  /** the offset of the attribute from the buffer, defaults to 0 */
+  offset?: number;
+  /** is this an instanced buffer? (defaults to false) */
+  instance?: boolean;
+  /**  The number of elements to be rendered. If not specified, all vertices after the starting vertex will be drawn. */
+  size?: number;
+  /** the type of attribute  */
+  type?: number;
+  /**
+   * The starting vertex in the geometry to start drawing from. If not specified,
+   *  drawing will start from the first vertex.
+   */
+  start?: number;
+  divisor?: number;
 }
 /**
  * The attribute options used by the constructor for adding geometries attributes
  * extends {@link rendering.Attribute} but allows for the buffer to be a typed or number array
  * @memberof rendering
  */
-type AttributesOption = Omit<Attribute, 'buffer'> & {
-    buffer: Buffer | TypedArray | number[];
-} | Buffer | TypedArray | number[];
+type AttributesOption =
+  | (Omit<Attribute, "buffer"> & {
+      buffer: Buffer | TypedArray | number[];
+    })
+  | Buffer
+  | TypedArray
+  | number[];
 /**
  * the interface that describes the structure of the geometry
  * @memberof rendering
  */
 export interface GeometryDescriptor {
-    /** an optional label to easily identify the geometry */
-    label?: string;
-    /** the attributes that make up the geometry */
-    attributes: Record<string, AttributesOption>;
-    /** optional index buffer for this geometry */
-    indexBuffer?: Buffer | TypedArray | number[];
-    /** the topology of the geometry, defaults to 'triangle-list' */
-    topology?: Topology;
-    instanceCount?: number;
+  /** an optional label to easily identify the geometry */
+  label?: string;
+  /** the attributes that make up the geometry */
+  attributes: Record<string, AttributesOption>;
+  /** optional index buffer for this geometry */
+  indexBuffer?: Buffer | TypedArray | number[];
+  /** the topology of the geometry, defaults to 'triangle-list' */
+  topology?: Topology;
+  instanceCount?: number;
 }
 /**
  * A Geometry is a low-level object that represents the structure of 2D shapes in terms of vertices and attributes.
@@ -88,64 +93,64 @@ export interface GeometryDescriptor {
  * @class
  */
 export declare class Geometry extends EventEmitter<{
-    update: Geometry;
-    destroy: Geometry;
+  update: Geometry;
+  destroy: Geometry;
 }> {
-    /** The topology of the geometry. */
-    topology: Topology;
-    /** The unique id of the geometry. */
-    readonly uid: number;
-    /** A record of the attributes of the geometry. */
-    readonly attributes: Record<string, Attribute>;
-    /** The buffers that the attributes use */
-    readonly buffers: Buffer[];
-    /** The index buffer of the geometry */
-    readonly indexBuffer: Buffer;
-    /**
-     * the layout key will be generated by WebGPU all geometries that have the same structure
-     * will have the same layout key. This is used to cache the pipeline layout
-     * @internal
-     * @ignore
-     */
-    _layoutKey: number;
-    /** the instance count of the geometry to draw */
-    instanceCount: number;
-    private readonly _bounds;
-    private _boundsDirty;
-    /**
-     * Create a new instance of a geometry
-     * @param options - The options for the geometry.
-     */
-    constructor(options: GeometryDescriptor);
-    protected onBufferUpdate(): void;
-    /**
-     * Returns the requested attribute.
-     * @param id - The name of the attribute required
-     * @returns - The attribute requested.
-     */
-    getAttribute(id: string): Attribute;
-    /**
-     * Returns the index buffer
-     * @returns - The index buffer.
-     */
-    getIndex(): Buffer;
-    /**
-     * Returns the requested buffer.
-     * @param id - The name of the buffer required.
-     * @returns - The buffer requested.
-     */
-    getBuffer(id: string): Buffer;
-    /**
-     * Used to figure out how many vertices there are in this geometry
-     * @returns the number of vertices in the geometry
-     */
-    getSize(): number;
-    /** Returns the bounds of the geometry. */
-    get bounds(): Bounds;
-    /**
-     * destroys the geometry.
-     * @param destroyBuffers - destroy the buffers associated with this geometry
-     */
-    destroy(destroyBuffers?: boolean): void;
+  /** The topology of the geometry. */
+  topology: Topology;
+  /** The unique id of the geometry. */
+  readonly uid: number;
+  /** A record of the attributes of the geometry. */
+  readonly attributes: Record<string, Attribute>;
+  /** The buffers that the attributes use */
+  readonly buffers: Buffer[];
+  /** The index buffer of the geometry */
+  readonly indexBuffer: Buffer;
+  /**
+   * the layout key will be generated by WebGPU all geometries that have the same structure
+   * will have the same layout key. This is used to cache the pipeline layout
+   * @internal
+   * @ignore
+   */
+  _layoutKey: number;
+  /** the instance count of the geometry to draw */
+  instanceCount: number;
+  private readonly _bounds;
+  private _boundsDirty;
+  /**
+   * Create a new instance of a geometry
+   * @param options - The options for the geometry.
+   */
+  constructor(options: GeometryDescriptor);
+  protected onBufferUpdate(): void;
+  /**
+   * Returns the requested attribute.
+   * @param id - The name of the attribute required
+   * @returns - The attribute requested.
+   */
+  getAttribute(id: string): Attribute;
+  /**
+   * Returns the index buffer
+   * @returns - The index buffer.
+   */
+  getIndex(): Buffer;
+  /**
+   * Returns the requested buffer.
+   * @param id - The name of the buffer required.
+   * @returns - The buffer requested.
+   */
+  getBuffer(id: string): Buffer;
+  /**
+   * Used to figure out how many vertices there are in this geometry
+   * @returns the number of vertices in the geometry
+   */
+  getSize(): number;
+  /** Returns the bounds of the geometry. */
+  get bounds(): Bounds;
+  /**
+   * destroys the geometry.
+   * @param destroyBuffers - destroy the buffers associated with this geometry
+   */
+  destroy(destroyBuffers?: boolean): void;
 }
 export {};
